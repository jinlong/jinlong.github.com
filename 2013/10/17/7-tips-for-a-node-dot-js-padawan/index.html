
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>面向Node.js新手的7个技巧 | Alon&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Alon Zhang">
    
    <meta name="description" content="原文：7 tips for a Node.js padawan感谢 Di Wu 同学，参考了他的译文《7 Tips for a Node.js Padawan》，某些不妥的地方做了些许修改。

或许我刚入门时就想了解这些知识。
Node.js 开发相当有趣，相当令人满足。它有 3 万 5 千多个模块">
    
    
    
    
    <link rel="alternative" href="atom.xml" title="Alon&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Alon&#39;s Blog">Alon&#39;s Blog</a></h1>
				<h2 class="blog-motto">一边翻译一边学习---涂鸦码龙</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">博客</a></li>
					
						<li><a href="/archives">存档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:jinlong.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2013/10/17/7-tips-for-a-node-dot-js-padawan/" title="面向Node.js新手的7个技巧" itemprop="url">面向Node.js新手的7个技巧</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://jinlong.github.io" title="Alon Zhang">Alon Zhang</a>
    </p>
  <p class="article-time">
    <time datetime="2013-10-17T09:38:00.000Z" itemprop="datePublished">10月 17 2013</time>
    更新日期:<time datetime="2013-10-27T10:18:20.000Z" itemprop="dateModified">10月 27 2013</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="# 或许我刚入门时就想了解这些知识。"><span class="toc-number">1.</span> <span class="toc-text">或许我刚入门时就想了解这些知识。</span></a></li></ol></ol><li class="toc-item toc-level-2"><a class="toc-link" href="# 技巧 _1_：开发环境使用 _nodemon，生产环境使用 _pm2"><span class="toc-number"></span> <span class="toc-text">技巧 1 ：开发环境使用 nodemon，生产环境使用 pm2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="# 技巧 _3_：轻松调试 _Node-js_ 应用 "><span class="toc-number"></span> <span class="toc-text">技巧 3 ：轻松调试 Node.js 应用</span></a></li></ol>
		</div>
		
		<blockquote>
<p>原文：<a href="https://medium.com/tech-talk/e7c0b0e5ce3c" target="_blank">7 tips for a Node.js padawan</a><br>感谢 <a href="http://diwu.me/about/index.html" target="_blank">Di Wu</a> 同学，参考了他的译文《<a href="http://diwu.me/2013/09/24/7-tips-for-a-node-dot-js-padawan/" target="_blank">7 Tips for a Node.js Padawan</a>》，某些不妥的地方做了些许修改。</p>
</blockquote>
<h4 id=" 或许我刚入门时就想了解这些知识。">或许我刚入门时就想了解这些知识。</h4>
<p>Node.js 开发相当有趣，相当令人满足。它有 3 万 5 千多个模块供君选择，总体而言，用 node 开发一个实际应用非常简单，并且扩展起来伸缩自如。</p>
<p>可是对于刚接触 Node.js 开发的同学，免不了遇到一些挫折。在这篇简短的文章中，我提到了一些学习 Node.js 时遇到的问题。</p>
<h2 id=" 技巧 _1_：开发环境使用 _nodemon，生产环境使用 _pm2">技巧 1 ：开发环境使用 nodemon，生产环境使用 pm2</h2>
<p>当你着手 Node.js  开发时，最突出的问题之一是，必须一次又一次的运行</p>
<figure class="highlight node"><figcaption><span>[file].js``` 。我开始学 node 时，这点相当令我抓狂。尤其是每次修改一点东西，都要 ```control + C``` 。</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre> 
幸运的是我发现了一个非常棒的工具 [<span class="link_label">Nodemon</span>](<span class="link_url">https://github.com/remy/nodemon</span>) 。运行以下命令安装它：
</pre></td></tr></table></figure>

<p>npm install -g nodemon</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre> 
Nodemon 了不起呀，一旦全局安装了它，你可以通过 <span class="code">```</span>nodemon [file].js<span class="code">```</span> 运行 node.js 脚本。nodemon 会监控你的代码，以及所有依赖代码的变化。如此开发 Node.js ，开发效率瞬间提高。
 
生产环境呢？除非你用了 Heroku，Nodejitsu 或者其它不错的 Node.js 托管服务，否则你可以试试 EC2 或者其它的云服务，通过它们运行你的 Node.js 应用。如何保证 Node.js 应用一直运行呢？

[<span class="link_label">PM2</span>](<span class="link_url">https://github.com/Unitech/pm2</span>) 像 nodemon ，用于在生产环境运行 node 应用。它会监控你的 app 变化并重新部署它们，不同之处在于，如果 PM2 遇到事故，它将立刻重启你的 node.js 应用。
 
当你的应用需要多核处理的时候，凸显出了 PM2 的优势。PM2 内部集成的“负载均衡”让你轻松指定 Node 应用运行几个实例。
</pre></td></tr></table></figure>

<p>pm2 start app.js -i max</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre> 
**-i** 参数用来指定运行多少个实例，此例中 PM2 使用了一个常量 **max** 自动扩展你的 app 运转到最大核数，不要忘记 Node 平时只运行在单核上！
&lt;!<span class="comment">--more--&gt;</span>
## 技巧 <span class="number">2</span> ：Async 或者 Q

越早写 node.js 应用，越会尽早领略回调地狱之痛。如果你没见过，这有一个例子：

```js
<span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">(name, password, cb)</span></span>{
  checkIfNameExists(name, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span></span>{
   <span class="keyword">if</span>(err){
    <span class="keyword">return</span> cb(“<span class="built_in">error</span>”);
   }
   checkIfPasswordGood(password, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span></span>{
    <span class="keyword">if</span>(err){
     <span class="keyword">return</span> cb(“<span class="built_in">error</span>”);
    }
 
    createAccount(name,password, <span class="function"><span class="keyword">function</span><span class="params">(err,result)</span></span>{
     <span class="keyword">if</span>(err){
      <span class="keyword">return</span> cb(“<span class="built_in">error</span>”);
     }
     createBlog(name, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span></span>{
      sendEmail(name, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span></span>{
       callback(result);
      });
     });
    });
   });
  });
}
</pre></td></tr></table></figure>

<p>不怎么美的神奇代码的确存在，但你如何避免呢？</p>
<p>一种简单的方式是用</p>
<figure class="highlight events```"><figcaption><span>，我个人不建议这么做，它违背了一个函数的观点，可以用 ```events``` 调用只有一个用途的私有方法。</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre> 
所以怎么做呢？有两个相互竞争的库：`<span class="javascript"></span>``<span class="javascript">async.js</span>``<span class="javascript"></span>` 和 `<span class="javascript"></span>``<span class="javascript">Q</span>``<span class="javascript"></span>` ，它们均可以避免回调地狱出现。
 
[Async.js](<span class="attribute">https</span>:<span class="regexp">//gi</span>thub.com/caolan/async) 或者 “async”可以轻松执行连续或者平行的函数，不需要一层一层的嵌套。
 
下面是 Async 支持的模式，readme 有记录。想了解 async 支持的所有模式，看看它们的代码仓库。

`<span class="javascript"></span>``<span class="javascript">js
async.map([‘file1<span class="string">',’file2'</span>,’file3<span class="string">'], fs.stat, function(err, results){
  // results is now an array of stats for each file
});
 
async.filter([‘file1'</span>,’file2<span class="string">',’file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span><span class="params">(results)</span>{</span>
<span class="comment">// results now equals an array of the existing files</span>
});
 
async.parallel([
  <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> … },
  <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> … }
  ], callback);
 
async.series([
  <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> … },
  <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> … }
  ]);
 
async.waterfall([
  <span class="function"><span class="keyword">function</span><span class="params">(callback)</span>{</span>
   callback(<span class="literal">null</span>, ‘one’, ‘two’);
  },
  <span class="function"><span class="keyword">function</span><span class="params">(arg1, arg2, callback)</span>{</span>
   callback(<span class="literal">null</span>, ‘three’);
  },
  <span class="function"><span class="keyword">function</span><span class="params">(arg1, callback)</span>{</span>
<span class="comment">// arg1 now equals ‘three’</span>
callback(<span class="literal">null</span>, ‘done’);
}
], <span class="function"><span class="keyword">function</span> <span class="params">(err, result)</span> {</span>
<span class="comment">// result now equals ‘done’</span>
});</span>
</pre></td></tr></table></figure>

<p>如果我们用 async 的</p>
<figure class="highlight waterfall```"><figcaption><span>来修改之前的例子，代码将更加易读，再也不会涉及死亡金字塔了。</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre> 
另一个很好的库是 [<span class="link_label">Q</span>](<span class="link_url">https://github.com/kriskowal/q</span>) ，这个库用到了 promises 的概念。Promise 是一个含有‘promise’方法的返回对象，他提供了一个最终返回值，非常优雅的将 javascripts 的异步特性和 node.js 紧密联系起来。
 
从 Q 的代码仓库页拿来的例子。

<span class="code">```</span>js
promiseMeSomething()
.then(function (value) {
}, function (reason) {
});
</pre></td></tr></table></figure>

<p>promise me 函数立刻返回一个对象，调用</p>
<figure class="highlight then```"><figcaption><span>将返回传入 value 值的函数。它也带一个回调函数，处理未能返回值的情况。</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre> 
用非常整洁的方式避免了回调地狱。如果重写原来的例子，当 ```<span class="keyword">then</span>``` 执行的时候才调用每个函数。

```js
<span class="transposed_variable">Q.</span>fcall(checkIfNameExists)
.<span class="keyword">then</span>(checkIfPasswordIsGood)
.<span class="keyword">then</span>(createAccount)
.<span class="keyword">then</span>(createBlog)
.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> {</span>
<span class="comment">// Do something with the result</span>
})
.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
<span class="comment">// Handle any error from all above steps</span>
})
.done();
</pre></td></tr></table></figure>

<p>如前面所说，我不喜欢创建单一目标函数。取而代之，用 “then”传递函数，仅传递一个匿名函数，当然选择权在你手中。</p>
<p>总之，当你掉入回调地狱时，是该关注下 async.js 或者 Q 了。</p>
<blockquote>
<p>“我个人喜好？一直是 Q！”</p>
</blockquote>
<h2 id=" 技巧 _3_：轻松调试 _Node-js_ 应用 ">技巧 3 ：轻松调试 Node.js 应用</h2>
<p>如果你从一个 IDE 重度集成的语言比如 java 或者 C# 转来调试 Node.js，你一定会感到很困扰。大多数新的 node 开发者采用 “flow”调试模式，你最好的帮手是</p>
<figure class="highlight console.log```"><figcaption><span>。</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre> 
但是肯定有更便利的调试方式，Node.js 内置了一个调试器你可以叫它 node debug，不过我更喜欢的 <span class="code">```</span>node-inspector<span class="code">```</span> 。
 
它们的 github 仓库提到“Node Inspector 是使用了 Blink 开发工具的 node.js 调试工具界面（先前的 WebKit Web Inspector）。”
 
简而言之，无论你选择哪个编辑器和 chrome web tools ，node-inspector 都可以调试你的应用。多爽啊。
 
Node Inspector 可以做一些真正酷的东西，比如实时代码修改，单步调试，作用域注入和一堆很酷的功能。
 
它涉及到一些设置，可以按照 [<span class="link_label">这里</span>](<span class="link_url">https://github.com/node-inspector/node-inspector</span>) 的说明做。

<span class="header">## 技巧 4 ：Nodefly</span>

一旦你的应用正常运行，你可能会问自己，如何监控它的性能，如何通过分析确保它以最佳速度运行呢。最简单的回答是使用非常棒的 Nodefly 服务。
 
通过一行简单的代码，Nodefly 开始监控应用程序的内存泄露， 测量 redis 用了多久，mongo 查询和一堆其他很酷的东西。
 
[<span class="link_label">http://www.nodefly.com/</span>](<span class="link_url">http://www.nodefly.com/</span>)

<span class="header">## 技巧 5 ：用 NPM 管理模块</span>

node 最寻常的事情之一是通过 NPM 安装程序包。Node 有个神奇的包管理器，它会安装 package.json 清单文件里指定的模块。可是初学者都会遇到一件事情，package.json 文件中所有使用的模块如何保持最新。
 
总是打开 package.json 更新已安装模块的依赖属性似乎很痛苦，很多人不知道 npm 可以帮你做这些！
 
简单运行 npm install — save module_name ，npm 将自动更新带有正确模块和版本号的 package.json
</pre></td></tr></table></figure>

<p>npm install —save module_name</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>
<span class="comment">## 技巧 6 ：不要提交 node_modules 文件夹</span>

我们一直谈论模块和 <span class="built_in">npm</span> ，还有人不知道不该提交 `<span class="javascript"></span>``<span class="javascript">node_modules</span>``<span class="javascript"></span>` 文件夹，最大的原因是没有必要提交。当别人检出你的代码，他们可以用 <span class="built_in">npm</span> 安装所需模块。
 
你也许会说提交 node_modules 文件夹无伤大雅，但是如果检出你代码的人用跟你不同的操作系统呢，通过 <span class="built_in">npm</span> 安装的模块是编译过的？你的应用会崩溃，检出你代码的人完全不知道为什么！
 
举例来说，当你安装过 bcrypt 和 sentimental 模块后，它们在主机上是编译过的，因为它们的原始组件是用 C 写的。
 
最优的作法是把 node_modules 文件夹加到 .gitignore 里，避免提交它。
</pre></td></tr></table></figure>

<p>// .gitignore node_modules/*</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
## 技巧 <span class="number">7</span> ：不要忘记 <span class="keyword">return</span>

刚入门的 node 开发者通常容易犯个错误，callback 回调函数后面忘加 <span class="keyword">return</span> 。虽然有时候没什么影响，多数情况你会遇到奇怪的问题，callback 回调执行了两次。
 
看个简单的例子：

```js
<span class="function"><span class="keyword">function</span> <span class="title">do</span><span class="params">(err,result, callback)</span></span>{
<span class="keyword">if</span>(err){
callback(“<span class="built_in">error</span>”);
}
callback(“good”);
}
</pre></td></tr></table></figure>


<p>乍一看，没什么问题。如果有错误，把 “error”传入 callback，没错则传递“good”。但是调用 callback 以后并没有停止执行，会接着调用 callback(“good”) 。</p>
<p>在复杂的代码中，加上 return 会节约数小时的调试时间。</p>
<hr>
<p>Node.js 是个很赞的开发平台，如果你谨记这 7 条技巧，开发，调试和部署到生产环境时，可以节省不少时间，防止头发尽早变灰白。</p>
<p>需要 Node.js 咨询？联系 <a href="http://www.dynamatik.com/" target="_blank">Dynamatik</a> 吧。</p>
  
	</div>
		<footer class="article-footer clearfix">


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Node.js/">Node.js</a>►<a class="article-category-link" href="/categories/Node.js/入门/">入门</a>
</div>



<div class="article-share" id="share">

  
<div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a class="jiathis_button_twitter">Twitter</a>
    <a class="jiathis_button_evernote">EverNote</a>
    <a href="http://www.jiathis.com/share?uid=1501277" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
</div>
<script type="text/javascript" >
    var jiathis_config={
    data_track_clickback:true,
    sm:"copy,renren,cqq",
    pic:"",
    summary:"",
     ralateuid:{"tsina":"1608907662"},hideMore:false}
    
  </script> 
<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=
1359953759521102" charset="utf-8"></script>      


</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2013/10/20/ten-years-of-sliding-doors-of-css/" title="CSS 滑动门十年纪念">
  <strong>PREVIOUS:</strong><br/>
  <span>
  CSS 滑动门十年纪念</span>
</a>
</div>


<div class="next">
<a href="/2013/10/02/client-side-full-text-search-in-css/"  title="用 CSS 实现客户端全文搜索">
 <strong>NEXT:</strong><br/> 
 <span>用 CSS 实现客户端全文搜索
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="# 或许我刚入门时就想了解这些知识。"><span class="toc-number">1.</span> <span class="toc-text">或许我刚入门时就想了解这些知识。</span></a></li></ol></ol><li class="toc-item toc-level-2"><a class="toc-link" href="# 技巧 _1_：开发环境使用 _nodemon，生产环境使用 _pm2"><span class="toc-number"></span> <span class="toc-text">技巧 1 ：开发环境使用 nodemon，生产环境使用 pm2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="# 技巧 _3_：轻松调试 _Node-js_ 应用 "><span class="toc-number"></span> <span class="toc-text">技巧 3 ：轻松调试 Node.js 应用</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Handlebars/" title="Handlebars">Handlebars<sup>1</sup></a></li>
		
			<li><a href="/tags/Node.js/" title="Node.js">Node.js<sup>1</sup></a></li>
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Handlebars/" style="font-size: NaNpx;">Handlebars</a><a href="/tags/Node.js/" style="font-size: NaNpx;">Node.js</a>
    </div>
  </div>


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://www.gaiyong.me/" target="_blank">[低调的产品经理] <strong>敏感的胖子</strong></a></li>
      <li><a href="http://www.xcodezone.com/" target="_blank">[PHP架构师] <strong>jiangfeng3</strong></a></li>
      <li><a href="http://www.stylejar.com/" target="_blank">[热衷IOS的 PHP Coder] <strong>c小淡</strong></a></li>
      <li><a href="http://yangjian.me" target="_blank" title="YangJian">Alimon's Blog</a></li>
      <li><a href="http://hexo.io/" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hi~ I&#39;m Alon Zhang, Doodler and Coder <br/>
			忙时码代码，无事乱涂鸦</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/newwave" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/jinlong" target="_blank" title="github"></a>
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://jinlong.github.io" target="_blank" title="Alon Zhang">Alon Zhang</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"jinlong"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F2bd777ce3d5910b5c44deb753c24f3e3' type='text/javascript'%3E%3C/script%3E"));
</script>


  </body>
</html>
